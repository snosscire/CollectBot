namespace modifies String {
	function toBoolean( string value ) {
		if( value.toLower() == 'yes' or
			value.toLower() == 'true' or
			value == '1' )
		{
			return true;
		}
		return false;
	}
}

namespace modifies Array {
	function sectionNames( array list ) {
		array sections;
		array have;
		list.each() using ( o ) {
			if( not have.keyExists(o.section) )
				sections[] = o.section;
		};
		return sections;
	}
	function bySectionAndName( array list, string section, string name ) {
		object match;
		list.each() using ( entry ) {
			if( entry.section == section and entry.name == name ) {
				match = entry;
				return false; // break
			}
		};
		return match;
	}
	function valueBySectionAndName( array list, string section, string name, void defaultValue ) {
		object match = list.bySectionAndName(section, name);
		if( match ) {
			if( defaultValue isa boolean ) return match.value.toBoolean();
			if( defaultValue isa number )  return match.value.toNumber();
			return match.value;
		}
		return defaultValue;
	}
	function byName( array list, string name ) {
		object match;
		list.each() using ( entry ) {
			if( entry.name == name ) {
				match = entry;
				return false; // break
			}
		};
		return match;
	}
	function valueByName( array list, string name, void defaultValue ) {
		object match = list.byName(name);
		if( match ) {
			if( defaultValue isa boolean ) return match.value.toBoolean();
			if( defaultValue isa number )  return match.value.toNumber();
			return match.value;
		}
		return defaultValue;
	}
	function listBySection( array list, string section ) {
		array matches;
		list.each() using( entry ) {
			if( entry.section == section )
				matches[] = entry;
		};
		return matches;
	}
}

class MapLayer {
	number x;
	number y;
	number level;
	number speed;
	object texture;

	function render( object camera ) {
		number screenX;
		number screenY = .y - camera.top;
		number extra = 0;
		do {
			screenX = ((.x - camera.left) * .speed).floor() + extra;
			if( screenX + .texture.width >= 0 )
				Engine.renderTexture(.texture, screenX, screenY);
			extra += .texture.width;
		} while( screenX + .texture.width < camera.screenWidth );
	}
}

class MapTile {
	static string TYPE_GROUND = 'ground';
	static string TYPE_COIN = 'coin';

	number x;
	number y;
	object texture;
	string type;
	boolean alive;

	function render( object camera ) {
		if( .alive ) {
			number screenX = .x - camera.left;
			number screenY = .y - camera.top;
			if( screenX + .texture.width >= 0 and screenX <= camera.screenWidth )
				Engine.renderTexture(.texture, screenX, screenY);
		}
	}

	function remove() {
		.alive = false;
	}
}

class Map {
	array layers;
	array tiles;
	array objects;
	number width;
	number height;
	number tileWidth;
	number tileHeight;

	static function load( string name ) {
		string basePath = "Resources/Maps/${name}/";
		object map = new Map();
		array config = Engine.parseINI(basePath + 'Map.ini');

		map.width = config.valueByName('MapWidth', 1920);
		map.height = config.valueByName('MapHeight', 1080);
		map.tileWidth = config.valueByName('TileWidth', 10);
		map.tileHeight = config.valueByName('TileHeight', 10);

		map.loadLayers(basePath);
		map.loadTiles(basePath);

		return map;
	}

	function loadLayers( string basePath ) {
		array config = Engine.parseINI(basePath + 'Layers.ini');
		array sections = config.sectionNames();

		sections.each() using ( section ) {
			array list = config.listBySection(section);
			object texture = Engine.loadTexture(basePath + 'Layers/' + list.valueByName('Texture', ''));

			if( texture ) {
				number x = list.valueByName('X', 0);
				number y = list.valueByName('Y', 0);
				object layer = new MapLayer();
				layer.x = (x >= 0 ? x : .width + x);
				layer.y = (y >= 0 ? y : .height + y);
				layer.level = list.valueByName('Level', 0);
				layer.speed = list.valueByName('Speed', 0);
				layer.texture = texture;
				.layers[] = layer;
			}
		};
	}

	function loadTiles( string basePath ) {
		object image = Engine.loadImage(basePath + 'Map.png');
		if( image ) {
			array config = Engine.parseINI(basePath + 'Tiles.ini');
			array sections = config.sectionNames();
			array textures;
			array types;

			sections.each() using ( section ) {
				array list = config.listBySection(section);
				number color = image.getColor(list.valueByName('Red', 0),
					                          list.valueByName('Green', 0),
					                          list.valueByName('Blue', 0));
				object texture = Engine.loadTexture(basePath + 'Tiles/' + list.valueByName('Texture', ''));
				if( texture ) {
					textures["$color"] = texture;
					types["$color"] = list.valueByName('Type', 'ground').toLower();
				}
			};

			for( number y = 0; y < image.height; y++ ) {
				for( number x = 0; x < image.width; x++ ) {
					number color = image.getPixel(x, y);
					if( textures.keyExists("$color") ) {
						object tile = new MapTile();
						tile.x = x * .tileWidth;
						tile.y = y * .tileHeight;
						tile.texture = textures["$color"];
						tile.type = types["$color"];
						tile.alive = true;

						if( tile.type == MapTile.TYPE_GROUND )
							.tiles[] = tile;
						else
							.objects[] = tile;
					}
				}
			}
		}
	}

	function renderBackground( object camera ) {
		.layers.each() using ( layer ) {
			if( layer.level <= 0 ) {
				layer.render(camera);
			}
		};
		.tiles.each() using ( tile ) {
			tile.render(camera);
		};
		.objects.each() using ( o ) {
			o.render(camera);
		};
	}

	function renderForeground( object camera ) {
		.layers.each() using ( layer ) {
			if( layer.level > 0 ) {
				layer.render(self, camera);
			}
		};
	}

	function hasCollisionWithGround( object player ) {
		boolean has = false;
		.tiles.each() using ( tile ) {
			has = Engine.hasIntersection(tile.x,
			                             tile.y,
			                             .tileWidth,
			                             .tileHeight,
			                             player.x - (player.width / 2),
			                             player.y - (player.height / 2),
			                             player.width,
			                             player.height);
			if( has )
				return false; // break;
		};
		return has;
	}

	function checkForCollisionWithObject( object player ) {
		boolean has;
		.objects.each() using ( o ) {
			if( o.alive ) {
				has = Engine.hasIntersection(o.x,
				                             o.y,
				                             .tileWidth,
				                             .tileHeight,
				                             player.x - (player.width / 2),
				                             player.y - (player.height / 2),
				                             player.width,
				                             player.height);
				if( has )
					player.onObjectCollision(o);
			}
		};
	}

	function resetObjects() {
		.objects.each() using ( o ) {
			o.alive = true;
		};
	}
}
