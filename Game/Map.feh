namespace modifies String {
	function toBoolean( string value ) {
		if( value.toLower() == 'yes' or
			value.toLower() == 'true' or
			value == '1' )
		{
			return true;
		}
		return false;
	}
}

namespace modifies Array {
	function sectionNames( array list ) {
		array sections;
		array have;
		list.each() using ( o ) {
			if( not have.keyExists(o.section) )
				sections[] = o.section;
		};
		return sections;
	}
	function bySectionAndName( array list, string section, string name ) {
		object match;
		list.each() using ( entry ) {
			if( entry.section == section and entry.name == name ) {
				match = entry;
				return false; // break
			}
		};
		return match;
	}
	function valueBySectionAndName( array list, string section, string name, void defaultValue ) {
		object match = list.bySectionAndName(section, name);
		if( match ) {
			if( defaultValue isa boolean ) return match.value.toBoolean();
			if( defaultValue isa number )  return match.value.toNumber();
			return match.value;
		}
		return defaultValue;
	}
	function byName( array list, string name ) {
		object match;
		list.each() using ( entry ) {
			if( entry.name == name ) {
				match = entry;
				return false; // break
			}
		};
		return match;
	}
	function valueByName( array list, string name, void defaultValue ) {
		object match = list.byName(name);
		if( match ) {
			if( defaultValue isa boolean ) return match.value.toBoolean();
			if( defaultValue isa number )  return match.value.toNumber();
			return match.value;
		}
		return defaultValue;
	}
	function listBySection( array list, string section ) {
		array matches;
		list.each() using( entry ) {
			if( entry.section == section )
				matches[] = entry;
		};
		return matches;
	}
}

class MapLayer {
	number x;
	number y;
	number level;
	number speed;
	object texture;

	function render( object camera ) {
		number screenX;
		number screenY = .y - camera.top;
		number extra = 0;
		do {
			screenX = ((.x - camera.left) * .speed) + extra;
			if( screenX + .texture.width >= 0 )
				Engine.renderTexture(.texture, screenX, screenY);
			extra += .texture.width;
		} while( screenX + .texture.width < Config.ScreenWidth );
	}
}

class MapTile {
	number x;
	number y;
	object texture;

	function render( object camera ) {
		number screenX = .x - camera.left;
		number screenY = .y - camera.top;
		if( screenX + .texture.width >= 0 and screenX <= Config.ScreenWidth )
			Engine.renderTexture(.texture, screenX, screenY);
	}
}

class Map {
	array layers;
	array tiles;
	number width;
	number height;
	number tileWidth;
	number tileHeight;

	static function load( string name ) {
		string basePath = "Resources/Maps/${name}/";
		object map = new Map();
		array config = Engine.parseINI(basePath + 'Map.ini');

		map.width = config.valueByName('MapWidth', 1920);
		map.height = config.valueByName('MapHeight', 1080);
		map.tileWidth = config.valueByName('TileWidth', 10);
		map.tileHeight = config.valueByName('TileHeight', 10);

		map.loadLayers(basePath);
		map.loadTiles(basePath);

		return map;
	}

	function loadLayers( string basePath ) {
		array config = Engine.parseINI(basePath + 'Layers.ini');
		array sections = config.sectionNames();

		sections.each() using ( section ) {
			array list = config.listBySection(section);
			object texture = Engine.loadTexture(basePath + 'Layers/' + list.valueByName('Texture', ''));

			if( texture ) {
				number x = list.valueByName('X', 0);
				number y = list.valueByName('Y', 0);
				object layer = new MapLayer();
				layer.x = (x >= 0 ? x : .width + x);
				layer.y = (y >= 0 ? y : .height + y);
				layer.level = list.valueByName('Level', 0);
				layer.speed = list.valueByName('Speed', 0);
				layer.texture = texture;
				.layers[] = layer;
			}
		};
	}

	function loadTiles( string basePath ) {
		object image = Engine.loadImage(basePath + 'Map.png');
		if( image ) {
			array config = Engine.parseINI(basePath + 'Tiles.ini');
			array sections = config.sectionNames();
			array colors;

			sections.each() using ( section ) {
				array list = config.listBySection(section);
				number color = image.getColor(list.valueByName('Red', 0),
					                          list.valueByName('Green', 0),
					                          list.valueByName('Blue', 0));
				object texture = Engine.loadTexture(basePath + 'Tiles/' + list.valueByName('Texture', ''));
				if( texture ) {
					colors["$color"] = texture;
				}
			};

			for( number y = 0; y < image.height; y++ ) {
				for( number x = 0; x < image.width; x++ ) {
					number color = image.getPixel(x, y);
					if( colors.keyExists("$color") ) {
						object tile = new MapTile();
						tile.x = x * .tileWidth;
						tile.y = y * .tileHeight;
						tile.texture = colors["$color"];
						.tiles[] = tile;
					}
				}
			}
		}
	}

	function renderBackground( object camera ) {
		.layers.each() using ( layer ) {
			if( layer.level <= 0 ) {
				layer.render(camera);
			}
		};
	}

	function renderForeground( object camera ) {
		.layers.each() using ( layer ) {
			if( layer.level > 0 ) {
				layer.render(self, camera);
			}
		};
		.tiles.each() using ( tile ) {
			tile.render(camera);
		};
	}

	function hasCollision( object o ) {
		boolean has = false;
		.tiles.each() using ( tile ) {
			has = Engine.hasIntersection(tile.x,
			                             tile.y,
			                             .tileWidth,
			                             .tileHeight,
			                             o.x - (o.width / 2),
			                             o.y - (o.height / 2),
			                             o.width,
			                             o.height);
			if( has )
				return false; // break;
		};
		return has;
	}
}
